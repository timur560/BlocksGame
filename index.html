<!DOCTYPE html>
<html>
<head>
	<style>
		body { background-color: white; }
	</style>
	<script src="./core/engine-common.js"></script>
	<script src="./canvasengine.js"></script>
	<script src="./extends/Input.js"></script>
	<script src="./extends/Hit.js"></script>
	<script src="./extends/Animation.js"></script>
	<script type="text/javascript">
		var cols = 5;
		var rows = 8;
		var canvasWidth = 640;
		var canvasHeight = 480;
		var blockWidth = canvasWidth / cols;
		var blockHeight = canvasHeight / rows;
		var slow = 1.5
		var fast = 8;
		var speed = slow;
		var color = 'rgb(0, 153, 204)';

		var canvas = CE.defines("game")
			.extend(Input)
			.extend(Hit)
			.extend(Animation)
			.ready(function() {
			canvas.Scene.call("MyGame");
		});

		canvas.Scene.New({
			name: "MyGame",
			blocks: [],
			colsFilled: [],
			updateBlocks: null,
			
			ready: function(stage) {
				var self = this;

				for (i = 0; i < cols; i++) {
					this.colsFilled[i] = [];
				}

				this.blocks[this.blocks.length] = this.createBlock(stage);

				canvas.Input.keyDown(Input.Left, function() {
					var currentBlock = self.blocks[self.blocks.length - 1];

					var lColHeight = (self.blocks.filter(function(element){
						return (element.el.x == currentBlock.el.x - blockWidth);
					}).length + 1) * blockHeight;

					if (currentBlock.el.x > 0 && (canvasHeight - lColHeight) > currentBlock.el.y) {
						self.blocks[self.blocks.length - 1].move(-blockWidth);
					}
				});

				canvas.Input.keyDown(Input.Bottom, function() {
					speed = fast;
				});

				canvas.Input.keyUp(Input.Bottom, function() {
					speed = slow;
				});

				canvas.Input.keyDown(Input.Right, function() {
					var currentBlock = self.blocks[self.blocks.length - 1];

					var rColHeight = (self.blocks.filter(function(element){
						return (element.el.x == currentBlock.el.x + blockWidth);
					}).length + 1)* blockHeight;

					if (currentBlock.el.x < (cols - 1) * blockWidth && (canvasHeight - rColHeight) > currentBlock.el.y) {
						self.blocks[self.blocks.length - 1].move(+blockWidth);
					}
				});
			},
			
			createBlock: function(stage) {
				this.curCol = Math.round((cols - 1) * Math.random());

				var block = Class.New('Entity', [stage]);
				block.rect(blockWidth, this.blockHeight);
				block.position(blockWidth * Math.round(Math.random() * 4), 0);
				block.el.fillStyle = color;
				block.el.opacity = (Math.round(Math.random() * 2) + 1) * 0.25;
				block.el.fillRect(0, 0, blockWidth, blockHeight);

				stage.append(block.el);
				return block;
			},
			
			updateRelatedBlocks: function(self) {
				var done = false;

				for (i = 0; i < self.blocks.length; i++) {
					for (j = 0; j < self.blocks.length; j++) {
						if (i != j 
								&& self.blocks[i].el.x == self.blocks[j].el.x
								&& self.blocks[i].el.y == self.blocks[j].el.y + blockHeight
								&& self.blocks[i].el.opacity == self.blocks[j].el.opacity
								&& self.blocks[i].el.opacity < 1) {

							self.blocks[j].el.remove();
							self.blocks.splice(j, 1);

							var timeline = canvas.Timeline.new(self.blocks[i].el);
							timeline.to(
								{opacity: self.blocks[i].el.opacity + 0.25}, 
								30, 
								Ease.easeOutCubic)
							.call();

							done = true;
						}
					}
				}

				if (done) {
					setTimeout(self.updateRelatedBlocks, 600, self);
				} else {
					setTimeout(self.updateRows, 500, self);
				}

			},

			updateRows: function(self) {
				// todo

				var done = false;

				var blocksMatrix = [];

				for (i = 0; i < rows; i++) {
					blocksMatrix[i] = [];
				}

				for (i = 0; i < self.blocks.length; i++) {
					blocksMatrix[Math.floor(self.blocks[i].el.y / blockHeight)][self.blocks[i].el.x / blockWidth] = i;
				}
				
				topMatrixLoop: 
				for (i = 0; i < rows; i++) {
					if (blocksMatrix[i].length < cols) continue;

					if (self.blocks[blocksMatrix[i][0]] != undefined) {
						opacity = self.blocks[blocksMatrix[i][0]].el.opacity;
					} else {
						continue;
					}

					for (j = 1; j < cols; j++) {
						if (self.blocks[blocksMatrix[i][j]] == undefined || self.blocks[blocksMatrix[i][j]].el.opacity != opacity) {
							continue topMatrixLoop;
						}
					}

					done = true;	

					// remove this row
					for (j = 0; j < cols; j++) {
						self.blocks[blocksMatrix[i][j]].el.remove();
						self.blocks.splice(blocksMatrix[i][j], 1);
					}

					// move all top blocks down
					for (k = i - 1; k > 0; k--) {
						for (j = 0; j < cols; j++) {
							if (self.blocks[blocksMatrix[k][j]] != undefined) {
								var timeline = canvas.Timeline.new(self.blocks[blocksMatrix[k][j]].el);
								timeline.to(
									{y: self.blocks[blocksMatrix[k][j]].el.y + blockHeight}, 
									30, 
									Ease.easeOutCubic)
								.call();
							}
						}
					}

					break;
				}

				if (done) {
					setTimeout(self.updateRows, 600, self);
				}

			},

			render: function(stage) {
				// console.log(this.blocks);
				// this.pause(true);
				var self = this;
				noMoving = true;
				var currentBlock = this.blocks[this.blocks.length - 1];

				var currentColHeight = this.blocks.filter(function(element){
					return (element.el.x == currentBlock.el.x);
				}).length * blockHeight;

				if (currentBlock.el.y < canvasHeight - currentColHeight) {
					this.blocks[this.blocks.length - 1].move(0, speed);
					// this.blocks[this.blocks.length - 1].el.x = this.curCol * blockWidth;
					noMoving = false;
				} else {
					if (currentColHeight > canvasHeight - blockHeight) this.pause(true);
					currentBlock.el.y = canvasHeight - currentColHeight;
				}

				if (noMoving) {

					var i = 0;

					this.updateRelatedBlocks(this);
					
					self.blocks[self.blocks.length] = self.createBlock(stage);
					speed = slow;

				}
				stage.refresh();
			}
		});
	</script>
</head>
<body>
	<canvas id="game" width="640" height="600"></canvas>
</body>
