<!DOCTYPE html>
<html>
<head>
	<style>
		body { background-color: #1d1d1d; }
	</style>
	<script src="./core/engine-common.js"></script>
	<script src="./canvasengine.js"></script>
	<script src="./extends/Input.js"></script>
	<script src="./extends/Hit.js"></script>
	<script src="./extends/Animation.js"></script>
	<script type="text/javascript">
		var cols = 5;
		var rows = 8;
		var canvasWidth = 640;
		var canvasHeight = 480;
		var blockWidth = canvasWidth / cols;
		var blockHeight = canvasHeight / rows;
		var speed = 1.5;
		var color = 'rgb(0, 153, 204)';

		var canvas = CE.defines("game")
			.extend(Input)
			.extend(Hit)
			.extend(Animation)
			.ready(function() {
			canvas.Scene.call("MyGame");
		});

		canvas.Scene.New({
			name: "MyGame",
			blocks: [],
			colsFilled: [],
			updateBlocks: null,
			
			ready: function(stage) {
				var self = this;

				for (i = 0; i < cols; i++) {
					this.colsFilled[i] = [];
				}

				this.blocks[this.blocks.length] = this.createBlock(stage);

				canvas.Input.keyDown(Input.Left, function() {
					var currentBlock = self.blocks[self.blocks.length - 1];

					var lColHeight = (self.blocks.filter(function(element){
						return (element.el.x == currentBlock.el.x - blockWidth);
					}).length + 1) * blockHeight;

					if (currentBlock.el.x > 0 && (canvasHeight - lColHeight) > currentBlock.el.y) {
						self.blocks[self.blocks.length - 1].move(-blockWidth);
					}
				});

				canvas.Input.keyDown(Input.Right, function() {
					var currentBlock = self.blocks[self.blocks.length - 1];

					var rColHeight = (self.blocks.filter(function(element){
						return (element.el.x == currentBlock.el.x + blockWidth);
					}).length + 1)* blockHeight;

					if (currentBlock.el.x < (cols - 1) * blockWidth && (canvasHeight - rColHeight) > currentBlock.el.y) {
						self.blocks[self.blocks.length - 1].move(+blockWidth);
					}
				});
			},
			
			createBlock: function(stage) {
				this.curCol = Math.round((cols - 1) * Math.random());

				var block = Class.New('Entity', [stage]);
				block.rect(blockWidth, this.blockHeight);
				block.position(blockWidth * Math.round(Math.random() * 4), 0);
				block.el.fillStyle = color;
				block.el.opacity = (Math.round(Math.random() * 2) + 1) * 0.25;
				block.el.fillRect(0, 0, blockWidth, blockHeight);

				stage.append(block.el);
				return block;
			},
			
			updateRelatedBlocks: function(self) {
				var done = false;

				for (i = 0; i < self.blocks.length; i++) {
					for (j = 0; j < self.blocks.length; j++) {
						if (i != j 
								&& self.blocks[i].el.x == self.blocks[j].el.x
								&& self.blocks[i].el.y == self.blocks[j].el.y + blockHeight
								&& self.blocks[i].el.opacity == self.blocks[j].el.opacity
								&& self.blocks[i].el.opacity < 1) {

							self.blocks[j].el.remove();
							self.blocks.splice(j, 1);

							var timeline = canvas.Timeline.new(self.blocks[i].el);
							timeline.to(
								{opacity: self.blocks[i].el.opacity + 0.25}, 
								30, 
								Ease.easeOutCubic)
							.call();

							done = true;
						}
					}
				}

				if (done) {
					setTimeout(this.updateRelatedBlocks, 500, self);
				} else {
					self.updateRows(self);
				}

			},

			updateRows: function(self) {
				// todo

				var done = false;

				var blocksMatrix = [];

				for (i = 0; i < rows; i++) {
					blocksMatrix[i] = [];
				}

				for (i = 0; i < self.blocks.length; i++) {
					blocksMatrix[self.blocks[i].el.y / blockHeight][self.blocks[i].el.x / blockWidth] = i;
				}
				
				console.log(blocksMatrix);

				// for (i = 0; i < self.blocks.length; i++) {
				// 	for (j = 0; j < self.blocks.length; j++) {
				// 		if (i != j 
				// 				&& self.blocks[i].el.x == self.blocks[j].el.x
				// 				&& self.blocks[i].el.y == self.blocks[j].el.y + blockHeight
				// 				&& self.blocks[i].el.opacity == self.blocks[j].el.opacity
				// 				&& self.blocks[i].el.opacity < 1) {

				// 			self.blocks[j].el.remove();
				// 			self.blocks.splice(j, 1);

				// 			var timeline = canvas.Timeline.new(self.blocks[i].el);
				// 			timeline.to(
				// 				{opacity: self.blocks[i].el.opacity + 0.25}, 
				// 				30, 
				// 				Ease.easeOutCubic)
				// 			.call();

				// 			done = true;
				// 		}
				// 	}
				// }

				if (done) {
					setTimeout(this.updateRows, 500, self);
				}

			},

			render: function(stage) {
				// console.log(this.blocks);
				// this.pause(true);
				var self = this;
				noMoving = true;
				var currentBlock = this.blocks[this.blocks.length - 1];

				var currentColHeight = this.blocks.filter(function(element){
					return (element.el.x == currentBlock.el.x);
				}).length * blockHeight;

				if (currentBlock.el.y < canvasHeight - currentColHeight) {
					this.blocks[this.blocks.length - 1].move(0, speed);
					// this.blocks[this.blocks.length - 1].el.x = this.curCol * blockWidth;
					noMoving = false;
				} else {
					if (currentColHeight > canvasHeight - blockHeight) this.pause(true);
					currentBlock.el.y = canvasHeight - currentColHeight;
				}

				if (noMoving) {

					var i = 0;

					this.updateRelatedBlocks(this);
					
					self.blocks[self.blocks.length] = self.createBlock(stage);

				}
				stage.refresh();
			}
		});
	</script>
</head>
<body>
	<canvas id="game" width="640" height="600"></canvas>
</body>
